package src;
/* TODO: Insert a comment here with the names of the driver and navigator, and a  
 * paragraph explaining the complexity of binary search (what it is using big-O
 * notation, and why it is whatever it is). A good explanation in your own words
 * is 1/3 of your grade for this lab.
 */

/**********************************************************
 * Assignment: Guess Your Number
 *
 * Author: Ben Radovitzky and Marcella Kamishlian
 *
 * Academic Integrity: We pledge that this program represents our own work. We
 * received help from no one in designing and debugging
 * our program.
 * 
 * Explanation of Big-O complexity:
 * We think that the complexity of this problem is O(log(n)). The reason we think this is the following.
 * In a sequential search algorithm, when one increases the size of the list that is being searched through,
 * the number of times that one has to iterate through it increases linearly with the size of the list.
 * However, in our algorithm, if we were to, say, multiply the size of the list by a factor of 2, the number
 * of times we would search through it would only increase by one. This shows that the time it takes to search
 * increases logarithmically instead of linearly, or any other way. Another way of looking at it is that when
 * we increase the size to very large numbers, and we were to graph the amount of time it takes, it would
 * almost look asymptotic, which implicates logarithmic behavior.
 **********************************************************/

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class BinarySearchTester 
{
	// you'll increment this inside your binarySearch method every time you compare
	// something with one of the values in your array.
	private static int comparisons = 0;
	
	// use the binary search algorithm to find the value target in the array
	// numbers, and return its index. Return -1 if target isn't in the array.
	private static int binarySearch(int target, int[] numbers)
	{
		// TODO: delete the line below and write the code to use
		// a binary search to find the target in numbers and return
		// its index. Be sure to also increment comparisons each
		// time you compare something with an element in numbers.
		int bot = 0;
		int top = numbers.length-1;
		int middle = 0;
		while(bot <= top)
		{
			middle = (bot + top) / 2;
			if(numbers[middle] == target) 
			{
				return middle;
			}
			else if(numbers[middle] < target)
			{
				bot = middle + 1;
			}
			else if(numbers[middle] > target) 
			{
				top = middle - 1;
			}
			comparisons++;
		}
		return -1;
		
	}
	private static int recursiveBinarySearch(int target, int[] numbers)
	{
		// TODO: delete the line below and write the code to use
		// a binary search to find the target in numbers and return
		// its index. Be sure to also increment comparisons each
		// time you compare something with an element in numbers.
		int midpoint = numbers.length/2;
		int[] top = Arrays.copyOfRange(numbers, midpoint, numbers.length);
		int[] bot = Arrays.copyOfRange(numbers, 0, midpoint);
		if(target == numbers[midpoint])
		{
			return midpoint;
		}
		else if(target < numbers[midpoint])
		{
			return recursiveBinarySearch(target, bot);
		}
		else if(target > numbers[midpoint])
		{
			return recursiveBinarySearch(target, top);
		}
		else
		{
			return -1;
		}
	}
	
	// main method will test your binary search code. you don't need to change anything
	// here or below, but feel free to look through the code below to see what it does 
	// if you're curious.
	public static void main(String[] args) 
	{
		int n = 75;
		int limit = 100;
		int[] numbers = createSortedArray(n, limit);
		System.out.println(Arrays.toString(numbers));
		
		Scanner scanner = new Scanner(System.in);
		System.out.print("What number (between 1 and " + limit + ") would you like to find? ");
		int target = scanner.nextInt();
		
		int yourLocation = recursiveBinarySearch(target, numbers);
		int myLocation = sequentialSearch(target, numbers);
		
		if (yourLocation == myLocation)
		{
			System.out.println("We both returned " + yourLocation + " as the location. Good job!");
			System.out.println("It took you " + comparisons + " comparisons to figure out if " + target + " is in a list of " + n + " numbers.");
		}
		else
		{
			System.out.println("You said the index was " + yourLocation + ", but I found " + target + " at index " + myLocation + ". Keep trying.");
		}
	}

	// this sequential search algorithm is used to verify your result.
	private static int sequentialSearch(int target, int[] numbers)
	{
		for (int i = 0; i < numbers.length; i++)
		{
			if (numbers[i] == target)
			{
				return i;
			}
		}
		return -1;
	}

	// this utility method creates a sorted array with size elements in it, between 1 and
	// limit, inclusive.
	private static int[] createSortedArray(int size, int limit)
	{
		// we don't want any repeats in the array (so the results from the sequential
		// and binary searches are consistent), so the size has to be less than or equal
		// to the limit.
		if (size > limit)
			throw new InvalidParameterException("The size of the array needs to be at least as large as the limit.");
		
		int[] result = new int[size];
		
		ArrayList<Integer> values = new ArrayList<Integer>();
		for (int i = 1; i <= limit; i++)
			values.add(i);
		
		for (int i = 0; i < size; i++)
		{
			int index = (int)(Math.random() * values.size());
			result[i] = values.get(index);
			values.remove(index);
		}
		
		Arrays.sort(result);
		return result;
	}
}